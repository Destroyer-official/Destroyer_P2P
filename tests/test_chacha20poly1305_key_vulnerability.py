#!/usr/bin/env python3
"""
Specific test for the ChaCha20-Poly1305 key size vulnerability that was fixed.

This test ensures that the system properly handles the key size requirements for
ChaCha20-Poly1305, which requires exactly 32 bytes for keys.

The previous vulnerability allowed a 33-byte key to be used, which led to:
1. Encryption failures with silent fallback to plaintext
2. Decryption failures with silent fallback to ciphertext
3. Misleading security logs that reported success despite failures
"""

import unittest
import os
import sys
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import required modules
from ca_services import CAExchange, SecurityError
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

# Configure test logging
logging.basicConfig(level=logging.ERROR)

class TestChaCha20Poly1305KeyVulnerability(unittest.TestCase):
    """Specific tests for the ChaCha20-Poly1305 key size vulnerability"""
    
    def test_key_size_validation_direct(self):
        """
        Test that ChaCha20Poly1305 directly validates key size and rejects invalid sizes.
        This is a basic test of the underlying cryptographic library's behavior.
        """
        # Test with correct size (32 bytes)
        key_correct = os.urandom(32)
        cipher = ChaCha20Poly1305(key_correct)  # Should not raise
        self.assertIsNotNone(cipher)
        
        # Test with too small key (31 bytes)
        key_small = os.urandom(31)
        with self.assertRaises(ValueError) as cm_small:
            ChaCha20Poly1305(key_small)
        self.assertIn("key must be 32 bytes", str(cm_small.exception))
        
        # Test with too large key (33 bytes) - This was the original vulnerability
        key_large = os.urandom(33)
        with self.assertRaises(ValueError) as cm_large:
            ChaCha20Poly1305(key_large)
        self.assertIn("key must be 32 bytes", str(cm_large.exception))
    
    def test_vulnerable_key_string(self):
        """
        Test the specific vulnerable key string that caused the issue.
        This test verifies that the exact key string that caused the vulnerability
        is properly handled by the current implementation.
        """
        # The original vulnerable key: 33 bytes
        original_vulnerable_key = b'SecureP2PCertificateExchangeKey!!'
        self.assertEqual(len(original_vulnerable_key), 33)
        
        # Verify the ChaCha20Poly1305 constructor correctly rejects it
        with self.assertRaises(ValueError):
            ChaCha20Poly1305(original_vulnerable_key)
    
    def test_hkdf_derivation_fix(self):
        """
        Test that the HKDF key derivation fix properly handles the vulnerable key.
        This test verifies that the implemented solution correctly derives a 32-byte
        key from the original vulnerable key.
        """
        # Original vulnerable 33-byte key
        original_key = b'SecureP2PCertificateExchangeKey!!'
        
        # Use HKDF to derive a proper 32-byte key
        hkdf = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'chacha20poly1305-exchange-key'
        )
        derived_key = hkdf.derive(original_key)
        
        # Verify length
        self.assertEqual(len(derived_key), 32, "Derived key should be exactly 32 bytes")
        
        # Verify it works with ChaCha20Poly1305
        try:
            cipher = ChaCha20Poly1305(derived_key)
            self.assertIsNotNone(cipher)
        except ValueError as e:
            self.fail(f"Derived key was rejected by ChaCha20Poly1305: {e}")
    
    def test_ca_exchange_key_initialization(self):
        """
        Test that CAExchange properly initializes its exchange key.
        This test verifies that the CAExchange class properly handles key derivation
        to ensure a correct-sized key is used.
        """
        # Create CAExchange with secure exchange enabled
        ca_exchange = CAExchange(secure_exchange=True)
        
        # Check that the exchange key exists and has correct length
        self.assertIsNotNone(ca_exchange.exchange_key)
        self.assertEqual(len(ca_exchange.exchange_key), 32,
                       "Exchange key should be exactly 32 bytes")
        
        # Verify it can be used with ChaCha20Poly1305 without error
        try:
            cipher = ChaCha20Poly1305(ca_exchange.exchange_key)
            self.assertIsNotNone(cipher)
        except ValueError as e:
            self.fail(f"Exchange key was rejected by ChaCha20Poly1305: {e}")
    
    def test_encryption_error_handling(self):
        """
        Test that encryption errors are properly handled and raised.
        This test verifies that the CAExchange._encrypt_data method properly
        handles encryption failures and raises errors instead of returning plaintext.
        """
        ca_exchange = CAExchange(secure_exchange=True)
        
        # Create a mock cipher that always fails
        class MockFailingCipher:
            def encrypt(self, *args, **kwargs):
                raise ValueError("Mock encryption failure")
        
        # Replace the real cipher with our mock
        ca_exchange.xchacha_cipher = MockFailingCipher()
        
        # Try to encrypt - should raise SecurityError instead of returning plaintext
        with self.assertRaises(SecurityError):
            ca_exchange._encrypt_data(b"test plaintext", associated_data=b"test aad")
    
    def test_decryption_error_handling(self):
        """
        Test that decryption errors are properly handled and raised.
        This test verifies that the CAExchange._decrypt_data method properly
        handles decryption failures and raises errors instead of returning ciphertext.
        """
        ca_exchange = CAExchange(secure_exchange=True)
        
        # Create a mock cipher that always fails
        class MockFailingCipher:
            def decrypt(self, *args, **kwargs):
                raise ValueError("Mock decryption failure")
        
        # Replace the real cipher with our mock
        ca_exchange.xchacha_cipher = MockFailingCipher()
        
        # Try to decrypt - should raise SecurityError instead of returning ciphertext
        with self.assertRaises(SecurityError):
            ca_exchange._decrypt_data(b"fake ciphertext", associated_data=b"test aad")
    
    def test_end_to_end_cert_encryption(self):
        """
        Test end-to-end certificate encryption and decryption with the fixed implementation.
        This test verifies that the fixed implementation correctly encrypts and decrypts
        certificate data without failures.
        """
        ca_exchange = CAExchange(secure_exchange=True)
        ca_exchange.generate_self_signed()
        
        # Get certificate data
        cert_data = ca_exchange.local_cert_pem
        self.assertIsNotNone(cert_data)
        
        # Create AAD for testing
        aad = b"test:127.0.0.1:12345:cert-exchange"
        
        # Encrypt the certificate data
        encrypted = ca_exchange._encrypt_data(cert_data, associated_data=aad)
        self.assertIsNotNone(encrypted)
        self.assertNotEqual(encrypted, cert_data)  # Should be different from plaintext
        
        # Decrypt the certificate data
        decrypted = ca_exchange._decrypt_data(encrypted, associated_data=aad)
        self.assertEqual(decrypted, cert_data)
        
        # Try with wrong AAD - should fail
        wrong_aad = b"wrong:127.0.0.1:12345:cert-exchange"
        with self.assertRaises(SecurityError):
            ca_exchange._decrypt_data(encrypted, associated_data=wrong_aad)


if __name__ == '__main__':
    unittest.main() 